# VSC HANDOFF: Task 2.1 — Strategy Base Classes and Interfaces

**Date:** 2026-02-09
**Requested By:** Phase 2 Kickoff Session
**Target Completion:** 2026-02-11
**Priority:** URGENT (Critical Path Entry Point)
**Recommended Model:** Sonnet (structured implementation)

---

## CONTEXT BLOCK

### Why This Task Exists
Task 2.1 establishes the foundational abstractions that all trading strategies inherit from. Without these base classes, Tasks 2.2-2.4 (individual strategy implementations) cannot proceed. This is the entry point to Phase 2's critical path.

### Dependencies
- **Upstream:** Phase 1 complete (Coverage 1.1.1-1.1.8 ✅)
- **Downstream:** Tasks 2.2, 2.3, 2.4 (all strategies depend on these base classes)

### Test Coverage Reference
- **Coverage 1.1.4** (Strategy Layer Tests - 85%): Defines the interface contracts
- Tests in `tests/unit/test_strategies.py` will validate this implementation

---

## AGENT EXECUTION BLOCK

### 1. OBJECTIVE

Implement the strategy layer base classes that define:
1. `StrategyBase` — Abstract base class all strategies inherit from
2. `Signal` — Dataclass representing a trading signal
3. `Direction` — Enum for signal direction (BUY, SELL, HOLD)
4. `StrategyType` — Enum for strategy identification (A, B, C)
5. `StrategyConfig` — Dataclass for strategy configuration parameters

These classes establish the contract that Coverage 1.1.4 tests validate against.

---

### 2. FILE STRUCTURE

Create the following files in the repository:

```
src/
├── strategies/
│   ├── __init__.py       # NEW — Package exports
│   ├── base.py           # NEW — StrategyBase, Signal, enums
│   └── config.py         # NEW — StrategyConfig dataclass
```

---

### 3. IMPLEMENTATION SPECIFICATION

#### File 1: `src/strategies/base.py`

```python
"""
Strategy base classes and signal definitions.

This module defines the core abstractions for the trading strategy layer:
- StrategyBase: Abstract base class all strategies must inherit
- Signal: Dataclass representing a trading signal
- Direction: Enum for signal direction
- StrategyType: Enum for strategy identification

CRITICAL CONTRACT:
- All strategies MUST return Signal objects from evaluate()
- Signal.confidence MUST be between 0.0 and 1.0
- Signals with confidence < 0.5 will be rejected by RiskManager (CRO-VERIFY-001)
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any

# =============================================================================
# ENUMS
# =============================================================================

class Direction(Enum):
    """Trading signal direction."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class StrategyType(Enum):
    """Strategy identification for the Crucible system."""
    A = "momentum_breakout"      # VIX < 18, trending markets
    B = "mean_reversion"         # VIX 18-25, choppy markets
    C = "cash_preservation"      # VIX > 25, crisis, or default


# =============================================================================
# SIGNAL DATACLASS
# =============================================================================

@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.

    Attributes:
        direction: BUY, SELL, or HOLD
        symbol: Ticker symbol (e.g., "SPY", "QQQ")
        confidence: Float 0.0 to 1.0 — signals below 0.5 are rejected
        rationale: Human-readable explanation of signal generation
        timestamp: When the signal was generated
        strategy_type: Which strategy generated this signal
        entry_price: Suggested entry price (optional)
        stop_loss: Suggested stop-loss price (optional)
        take_profit: Suggested take-profit price (optional)
        metadata: Additional signal context (optional)

    CRITICAL: confidence < 0.5 will be rejected by RiskManager per CRO-VERIFY-001
    """
    direction: Direction
    symbol: str
    confidence: float
    rationale: str
    timestamp: datetime
    strategy_type: StrategyType
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal constraints."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")

        if not self.symbol:
            raise ValueError("Symbol cannot be empty")

        if self.direction in (Direction.BUY, Direction.SELL):
            if self.entry_price is not None and self.entry_price <= 0:
                raise ValueError(f"Entry price must be positive, got {self.entry_price}")
            if self.stop_loss is not None and self.stop_loss <= 0:
                raise ValueError(f"Stop loss must be positive, got {self.stop_loss}")
            if self.take_profit is not None and self.take_profit <= 0:
                raise ValueError(f"Take profit must be positive, got {self.take_profit}")

    @property
    def is_actionable(self) -> bool:
        """Return True if this signal requires a trade action."""
        return self.direction in (Direction.BUY, Direction.SELL)

    @property
    def passes_confidence_gate(self) -> bool:
        """Return True if confidence meets minimum threshold (0.5)."""
        return self.confidence >= 0.5

    def to_dict(self) -> Dict[str, Any]:
        """Serialize signal to dictionary for logging/storage."""
        return {
            "direction": self.direction.value,
            "symbol": self.symbol,
            "confidence": self.confidence,
            "rationale": self.rationale,
            "timestamp": self.timestamp.isoformat(),
            "strategy_type": self.strategy_type.value,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "metadata": self.metadata,
        }


# =============================================================================
# MARKET DATA INTERFACE
# =============================================================================

@dataclass
class MarketData:
    """
    Market data snapshot passed to strategy evaluation.

    This is the input contract for StrategyBase.evaluate().
    """
    symbol: str
    timestamp: datetime
    price: float
    bid: float
    ask: float
    volume: int
    vwap: Optional[float] = None

    # Technical indicators (computed upstream)
    ema_fast: Optional[float] = None      # EMA 8
    ema_slow: Optional[float] = None      # EMA 21
    rsi: Optional[float] = None           # RSI 14
    bollinger_upper: Optional[float] = None
    bollinger_lower: Optional[float] = None
    bollinger_middle: Optional[float] = None

    # Historical context
    prior_day_high: Optional[float] = None
    prior_day_low: Optional[float] = None
    prior_day_close: Optional[float] = None

    def __post_init__(self):
        """Validate market data constraints."""
        if self.price <= 0:
            raise ValueError(f"Price must be positive, got {self.price}")
        if self.bid <= 0:
            raise ValueError(f"Bid must be positive, got {self.bid}")
        if self.ask <= 0:
            raise ValueError(f"Ask must be positive, got {self.ask}")
        if self.bid > self.ask:
            raise ValueError(f"Bid ({self.bid}) cannot exceed ask ({self.ask})")
        if self.volume < 0:
            raise ValueError(f"Volume cannot be negative, got {self.volume}")


# =============================================================================
# STRATEGY BASE CLASS
# =============================================================================

class StrategyBase(ABC):
    """
    Abstract base class for all trading strategies.

    All strategies in the Crucible system MUST inherit from this class
    and implement the evaluate() method.

    Contract:
        - evaluate() MUST return a Signal object
        - evaluate() MUST NOT raise exceptions during normal operation
        - evaluate() MUST return Direction.HOLD if conditions are not met

    Subclasses:
        - StrategyA (momentum_breakout): Task 2.2
        - StrategyB (mean_reversion): Task 2.3
        - StrategyC (cash_preservation): Task 2.4
    """

    def __init__(self, strategy_type: StrategyType, config: Optional["StrategyConfig"] = None):
        """
        Initialize strategy with type identifier and optional config.

        Args:
            strategy_type: Which strategy this is (A, B, or C)
            config: Optional configuration overrides
        """
        self._strategy_type = strategy_type
        self._config = config
        self._initialized_at = datetime.now()

    @property
    def strategy_type(self) -> StrategyType:
        """Return the strategy type identifier."""
        return self._strategy_type

    @property
    def config(self) -> Optional["StrategyConfig"]:
        """Return the strategy configuration."""
        return self._config

    @abstractmethod
    def evaluate(self, market_data: MarketData) -> Signal:
        """
        Evaluate market data and generate a trading signal.

        This is the core method that each strategy must implement.

        Args:
            market_data: Current market snapshot with technical indicators

        Returns:
            Signal object with direction, confidence, and rationale

        Contract:
            - MUST return a valid Signal object
            - MUST NOT raise exceptions (return HOLD with low confidence instead)
            - MUST include meaningful rationale for audit trail
        """
        pass

    def _create_hold_signal(
        self,
        symbol: str,
        rationale: str,
        confidence: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Signal:
        """
        Helper to create a HOLD signal.

        Use this when conditions for entry are not met.
        """
        return Signal(
            direction=Direction.HOLD,
            symbol=symbol,
            confidence=confidence,
            rationale=rationale,
            timestamp=datetime.now(),
            strategy_type=self._strategy_type,
            metadata=metadata or {},
        )

    def _create_buy_signal(
        self,
        symbol: str,
        confidence: float,
        rationale: str,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Signal:
        """
        Helper to create a BUY signal.

        All BUY signals require entry, stop-loss, and take-profit prices.
        """
        return Signal(
            direction=Direction.BUY,
            symbol=symbol,
            confidence=confidence,
            rationale=rationale,
            timestamp=datetime.now(),
            strategy_type=self._strategy_type,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            metadata=metadata or {},
        )

    def _create_sell_signal(
        self,
        symbol: str,
        confidence: float,
        rationale: str,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Signal:
        """
        Helper to create a SELL signal.

        For options, SELL typically means selling to close a long position,
        not initiating a short.
        """
        return Signal(
            direction=Direction.SELL,
            symbol=symbol,
            confidence=confidence,
            rationale=rationale,
            timestamp=datetime.now(),
            strategy_type=self._strategy_type,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            metadata=metadata or {},
        )

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(type={self._strategy_type.value})"
```

---

#### File 2: `src/strategies/config.py`

```python
"""
Strategy configuration dataclasses.

Each strategy (A, B, C) has configurable parameters within defined ranges.
This module provides the configuration structure.
"""

from dataclasses import dataclass, field
from typing import List, Optional


@dataclass
class StrategyAConfig:
    """
    Configuration for Strategy A: Momentum Breakout.

    Deployed when: VIX < 18, trending markets
    """
    # Symbol selection
    symbols: List[str] = field(default_factory=lambda: ["SPY", "QQQ"])
    max_symbols: int = 2

    # EMA parameters
    ema_fast_period: int = 8
    ema_slow_period: int = 21

    # RSI parameters
    rsi_period: int = 14
    rsi_min: float = 50.0   # Must be above this
    rsi_max: float = 65.0   # Must be below this

    # VWAP condition
    require_above_vwap: bool = True

    # Risk parameters (defaults from account parameters)
    max_risk_pct: float = 0.03          # 3% of capital ($18 on $600)
    max_position_pct: float = 0.20      # 20% of capital ($120 on $600)

    # Exit parameters
    take_profit_pct: float = 0.15       # 15%
    stop_loss_pct: float = 0.25         # 25%
    time_stop_minutes: int = 90

    # Options parameters
    min_dte: int = 2                    # Never 0DTE
    moneyness: str = "ATM"              # At-the-money


@dataclass
class StrategyBConfig:
    """
    Configuration for Strategy B: Mean Reversion Fade.

    Deployed when: VIX 18-25, choppy markets
    """
    # Symbol selection
    symbols: List[str] = field(default_factory=lambda: ["SPY"])
    max_symbols: int = 1

    # RSI parameters
    rsi_period: int = 14
    rsi_oversold: float = 30.0
    rsi_overbought: float = 70.0

    # Bollinger Band parameters
    bollinger_period: int = 20
    bollinger_std: float = 2.0
    require_band_touch: bool = True

    # Risk parameters (more conservative than A)
    max_risk_pct: float = 0.02          # 2% of capital ($12 on $600)
    max_position_pct: float = 0.10      # 10% of capital ($60 on $600)

    # Exit parameters
    take_profit_pct: float = 0.08       # 8% (quick scalp)
    stop_loss_pct: float = 0.15         # 15% (tighter)
    time_stop_minutes: int = 45

    # Options parameters
    min_dte: int = 5                    # More time for reversion
    moneyness: str = "OTM1"             # 1 strike out-of-the-money


@dataclass
class StrategyCConfig:
    """
    Configuration for Strategy C: Cash Preservation.

    Deployed when: VIX > 25, crisis, or default fallback

    CRITICAL: Strategy C NEVER initiates new positions.
    It only manages existing positions (force-close at 3 DTE).
    """
    # Symbol selection (none - no new entries)
    symbols: List[str] = field(default_factory=list)
    max_symbols: int = 0

    # Risk parameters
    max_risk_pct: float = 0.0           # Zero new risk
    max_position_pct: float = 0.0       # Zero new positions

    # Position management
    force_close_dte: int = 3            # Close all at 3 DTE
    emergency_stop_pct: float = 0.40    # 40% loss hard stop

    # Mode
    mode: str = "alert_only"            # Monitor and report, do not trade


@dataclass
class StrategyConfig:
    """
    Unified strategy configuration container.

    Holds configuration for whichever strategy is active.
    """
    strategy_a: Optional[StrategyAConfig] = None
    strategy_b: Optional[StrategyBConfig] = None
    strategy_c: Optional[StrategyCConfig] = None

    @classmethod
    def default_for_a(cls) -> "StrategyConfig":
        """Create config with Strategy A defaults."""
        return cls(strategy_a=StrategyAConfig())

    @classmethod
    def default_for_b(cls) -> "StrategyConfig":
        """Create config with Strategy B defaults."""
        return cls(strategy_b=StrategyBConfig())

    @classmethod
    def default_for_c(cls) -> "StrategyConfig":
        """Create config with Strategy C defaults."""
        return cls(strategy_c=StrategyCConfig())
```

---

#### File 3: `src/strategies/__init__.py`

```python
"""
Strategy layer for the Crucible trading system.

This package provides:
- StrategyBase: Abstract base class for all strategies
- Signal: Trading signal dataclass
- Direction, StrategyType: Core enums
- MarketData: Input contract for strategy evaluation
- Configuration classes for each strategy

USAGE:
    from src.strategies import StrategyBase, Signal, Direction, MarketData

    class MyStrategy(StrategyBase):
        def evaluate(self, market_data: MarketData) -> Signal:
            # Implementation here
            pass
"""

from .base import (
    StrategyBase,
    Signal,
    Direction,
    StrategyType,
    MarketData,
)

from .config import (
    StrategyConfig,
    StrategyAConfig,
    StrategyBConfig,
    StrategyCConfig,
)

__all__ = [
    # Core classes
    "StrategyBase",
    "Signal",
    "MarketData",

    # Enums
    "Direction",
    "StrategyType",

    # Configuration
    "StrategyConfig",
    "StrategyAConfig",
    "StrategyBConfig",
    "StrategyCConfig",
]
```

---

### 4. DEPENDENCIES

#### External Libraries (in pyproject.toml)
```python
from dataclasses import dataclass, field
from datetime import datetime
from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional, List, Dict, Any
```

No new external dependencies required.

#### Internal Dependencies
```python
# None — this is the foundational layer
# Future layers will import from here:
# from src.strategies import StrategyBase, Signal, Direction, MarketData
```

---

### 5. INPUT/OUTPUT CONTRACT

#### Input: MarketData (to strategy.evaluate())
```python
MarketData(
    symbol="SPY",
    timestamp=datetime.now(),
    price=580.50,
    bid=580.48,
    ask=580.52,
    volume=1_500_000,
    vwap=579.80,
    ema_fast=580.25,
    ema_slow=579.10,
    rsi=55.3,
    # ... other fields
)
```

#### Output: Signal (from strategy.evaluate())
```python
Signal(
    direction=Direction.BUY,
    symbol="SPY",
    confidence=0.72,
    rationale="EMA crossover bullish, RSI 55 in range, price above VWAP",
    timestamp=datetime.now(),
    strategy_type=StrategyType.A,
    entry_price=580.50,
    stop_loss=565.00,
    take_profit=595.00,
    metadata={"ema_diff": 1.15, "rsi": 55.3},
)
```

---

### 6. INTEGRATION POINTS

#### With Phase 1 Test Suite
Tests in `tests/unit/test_strategies.py` validate:
- Signal creation with valid/invalid inputs
- StrategyBase interface contract
- Direction enum values
- MarketData validation

**The test suite IS the specification.** Implementation must make tests pass.

#### With Task 2.2-2.4 (Individual Strategies)
```python
# Task 2.2: Strategy A
from src.strategies import StrategyBase, Signal, Direction, MarketData, StrategyType

class StrategyA(StrategyBase):
    def __init__(self, config=None):
        super().__init__(StrategyType.A, config)

    def evaluate(self, market_data: MarketData) -> Signal:
        # Momentum breakout logic
        pass
```

#### With Task 2.5 (Risk Layer)
```python
# Risk layer validates signals before execution
from src.strategies import Signal

def validate_signal(signal: Signal, account_state: AccountState) -> ValidatedSignal:
    if not signal.passes_confidence_gate:  # < 0.5
        raise RejectedSignal("Confidence below 0.5 threshold")
    # ... position sizing validation
```

---

### 7. DEFINITION OF DONE

- [ ] All existing tests pass (`pytest tests/`)
- [ ] New tests for Signal validation edge cases pass
- [ ] ruff + black pass with zero warnings
- [ ] mypy type checking passes
- [ ] StrategyBase can be subclassed without errors
- [ ] Signal.confidence validation works (0.0-1.0 range)
- [ ] Signal.passes_confidence_gate returns correct bool
- [ ] MarketData validation rejects invalid inputs
- [ ] All classes importable from `src.strategies`

---

### 8. EDGE CASES TO TEST

| Scenario | Expected Behavior |
|----------|-------------------|
| Signal confidence = -0.1 | ValueError raised |
| Signal confidence = 1.1 | ValueError raised |
| Signal confidence = 0.0 | Valid (HOLD signals) |
| Signal confidence = 1.0 | Valid |
| Signal confidence = 0.49 | passes_confidence_gate = False |
| Signal confidence = 0.50 | passes_confidence_gate = True |
| MarketData bid > ask | ValueError raised |
| MarketData price = 0 | ValueError raised |
| MarketData volume = -1 | ValueError raised |
| Empty symbol string | ValueError raised |

---

### 9. ROLLBACK PLAN

If issues arise:
1. Delete `src/strategies/` directory
2. Remove from `pyproject.toml` if any changes made
3. Run `pytest` to confirm no regressions
4. Document failure in task notes for diagnosis

---

### 10. COPILOT EXECUTION PROMPT

Copy this into VSCode with Copilot:

```
TASK: Implement Task 2.1 - Strategy Base Classes

I need to create the strategy layer foundation for a trading bot.

FILES TO CREATE:
1. src/strategies/__init__.py - Package exports
2. src/strategies/base.py - StrategyBase abstract class, Signal dataclass, enums
3. src/strategies/config.py - Configuration dataclasses for strategies A, B, C

KEY REQUIREMENTS:
- Signal.confidence must be validated (0.0 to 1.0)
- Signal.passes_confidence_gate property (>= 0.5 threshold)
- StrategyBase is ABC with abstract evaluate() method
- MarketData validates all numeric inputs
- All classes must be properly typed for mypy

QUALITY GATES:
- ruff check src/strategies/
- black --check src/strategies/
- mypy src/strategies/
- pytest tests/unit/test_strategies.py

See attached VSC Handoff document for complete specifications.
```

---

**Document Version:** 1.0
**Prepared By:** @Systems_Architect, Charter & Stone Capital
**Blueprint Follows:** VSC_HANDOFF_TEMPLATE_v2.md
**Model Routing:** Sonnet recommended for implementation
**Context Budget:** Low (single-focus task)
