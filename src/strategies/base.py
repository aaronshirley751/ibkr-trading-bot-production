"""
Strategy base classes and signal definitions.

This module defines the core abstractions for the trading strategy layer:
- StrategyBase: Abstract base class all strategies must inherit
- Signal: Dataclass representing a trading signal
- Direction: Enum for signal direction
- StrategyType: Enum for strategy identification

CRITICAL CONTRACT:
- All strategies MUST return Signal objects from evaluate()
- Signal.confidence MUST be between 0.0 and 1.0
- Signals with confidence < 0.5 will be rejected by RiskManager (CRO-VERIFY-001)
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Any, Dict, Optional

if TYPE_CHECKING:
    from .config import StrategyConfig


# =============================================================================
# ENUMS
# =============================================================================


class Direction(Enum):
    """Trading signal direction."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class StrategyType(Enum):
    """Strategy identification for the Crucible system."""

    A = "momentum_breakout"  # VIX < 18, trending markets
    B = "mean_reversion"  # VIX 18-25, choppy markets
    C = "cash_preservation"  # VIX > 25, crisis, or default


# =============================================================================
# SIGNAL DATACLASS
# =============================================================================


@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.

    Attributes:
        direction: BUY, SELL, or HOLD
        symbol: Ticker symbol (e.g., "SPY", "QQQ")
        confidence: Float 0.0 to 1.0 â€” signals below 0.5 are rejected
        rationale: Human-readable explanation of signal generation
        timestamp: When the signal was generated
        strategy_type: Which strategy generated this signal
        entry_price: Suggested entry price (optional)
        stop_loss: Suggested stop-loss price (optional)
        take_profit: Suggested take-profit price (optional)
        metadata: Additional signal context (optional)

    CRITICAL: confidence < 0.5 will be rejected by RiskManager per CRO-VERIFY-001
    """

    direction: Direction
    symbol: str
    confidence: float
    rationale: str
    timestamp: datetime
    strategy_type: StrategyType
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate signal constraints."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")

        if not self.symbol:
            raise ValueError("Symbol cannot be empty")

        if self.direction in (Direction.BUY, Direction.SELL):
            if self.entry_price is not None and self.entry_price <= 0:
                raise ValueError(f"Entry price must be positive, got {self.entry_price}")
            if self.stop_loss is not None and self.stop_loss <= 0:
                raise ValueError(f"Stop loss must be positive, got {self.stop_loss}")
            if self.take_profit is not None and self.take_profit <= 0:
                raise ValueError(f"Take profit must be positive, got {self.take_profit}")

    @property
    def is_actionable(self) -> bool:
        """Return True if this signal requires a trade action."""
        return self.direction in (Direction.BUY, Direction.SELL)

    @property
    def passes_confidence_gate(self) -> bool:
        """Return True if confidence meets minimum threshold (0.5)."""
        return self.confidence >= 0.5

    def to_dict(self) -> Dict[str, Any]:
        """Serialize signal to dictionary for logging/storage."""
        return {
            "direction": self.direction.value,
            "symbol": self.symbol,
            "confidence": self.confidence,
            "rationale": self.rationale,
            "timestamp": self.timestamp.isoformat(),
            "strategy_type": self.strategy_type.value,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "metadata": self.metadata,
        }


# =============================================================================
# MARKET DATA INTERFACE
# =============================================================================


@dataclass
class MarketData:
    """
    Market data snapshot passed to strategy evaluation.

    This is the input contract for StrategyBase.evaluate().
    """

    symbol: str
    timestamp: datetime
    price: float
    bid: float
    ask: float
    volume: int
    vwap: Optional[float] = None

    # Technical indicators (computed upstream)
    ema_fast: Optional[float] = None  # EMA 8
    ema_slow: Optional[float] = None  # EMA 21
    rsi: Optional[float] = None  # RSI 14
    bollinger_upper: Optional[float] = None
    bollinger_lower: Optional[float] = None
    bollinger_middle: Optional[float] = None

    # Historical context
    prior_day_high: Optional[float] = None
    prior_day_low: Optional[float] = None
    prior_day_close: Optional[float] = None

    def __post_init__(self) -> None:
        """Validate market data constraints."""
        if self.price <= 0:
            raise ValueError(f"Price must be positive, got {self.price}")
        if self.bid <= 0:
            raise ValueError(f"Bid must be positive, got {self.bid}")
        if self.ask <= 0:
            raise ValueError(f"Ask must be positive, got {self.ask}")
        if self.bid > self.ask:
            raise ValueError(f"Bid ({self.bid}) cannot exceed ask ({self.ask})")
        if self.volume < 0:
            raise ValueError(f"Volume cannot be negative, got {self.volume}")


# =============================================================================
# STRATEGY BASE CLASS
# =============================================================================


class StrategyBase(ABC):
    """
    Abstract base class for all trading strategies.

    All strategies in the Crucible system MUST inherit from this class
    and implement the evaluate() method.

    Contract:
        - evaluate() MUST return a Signal object
        - evaluate() MUST NOT raise exceptions during normal operation
        - evaluate() MUST return Direction.HOLD if conditions are not met

    Subclasses:
        - StrategyA (momentum_breakout): Task 2.2
        - StrategyB (mean_reversion): Task 2.3
        - StrategyC (cash_preservation): Task 2.4
    """

    def __init__(self, strategy_type: StrategyType, config: Optional["StrategyConfig"] = None):
        """
        Initialize strategy with type identifier and optional config.

        Args:
            strategy_type: Which strategy this is (A, B, or C)
            config: Optional configuration overrides
        """
        self._strategy_type = strategy_type
        self._config = config
        self._initialized_at = datetime.now()

    @property
    def strategy_type(self) -> StrategyType:
        """Return the strategy type identifier."""
        return self._strategy_type

    @property
    def config(self) -> Optional["StrategyConfig"]:
        """Return the strategy configuration."""
        return self._config

    @abstractmethod
    def evaluate(self, market_data: MarketData) -> Signal:
        """
        Evaluate market data and generate a trading signal.

        This is the core method that each strategy must implement.

        Args:
            market_data: Current market snapshot with technical indicators

        Returns:
            Signal object with direction, confidence, and rationale

        Contract:
            - MUST return a valid Signal object
            - MUST NOT raise exceptions (return HOLD with low confidence instead)
            - MUST include meaningful rationale for audit trail
        """
        pass

    def _create_hold_signal(
        self,
        symbol: str,
        rationale: str,
        confidence: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Signal:
        """
        Helper to create a HOLD signal.

        Use this when conditions for entry are not met.
        """
        return Signal(
            direction=Direction.HOLD,
            symbol=symbol,
            confidence=confidence,
            rationale=rationale,
            timestamp=datetime.now(),
            strategy_type=self._strategy_type,
            metadata=metadata or {},
        )

    def _create_buy_signal(
        self,
        symbol: str,
        confidence: float,
        rationale: str,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Signal:
        """
        Helper to create a BUY signal.

        All BUY signals require entry, stop-loss, and take-profit prices.
        """
        return Signal(
            direction=Direction.BUY,
            symbol=symbol,
            confidence=confidence,
            rationale=rationale,
            timestamp=datetime.now(),
            strategy_type=self._strategy_type,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            metadata=metadata or {},
        )

    def _create_sell_signal(
        self,
        symbol: str,
        confidence: float,
        rationale: str,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Signal:
        """
        Helper to create a SELL signal.

        For options, SELL typically means selling to close a long position,
        not initiating a short.
        """
        return Signal(
            direction=Direction.SELL,
            symbol=symbol,
            confidence=confidence,
            rationale=rationale,
            timestamp=datetime.now(),
            strategy_type=self._strategy_type,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            metadata=metadata or {},
        )

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(type={self._strategy_type.value})"
